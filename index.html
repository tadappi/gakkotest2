<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>GLB Viewer – 2 Sprites with Hover/Link</title>
<style>
  body {margin:0;overflow:hidden;background:#fff;}
  canvas{display:block}
  /* ─── ホバーラベル ─── */
  #tooltip{
    position:absolute;display:none;z-index:10;
    background:rgba(255,255,255,.95);border:1px solid #999;
    border-radius:6px;padding:6px;font:14px/1 sans-serif
  }
  #tooltip img{width:160px;height:auto;display:block;margin-bottom:4px}
</style>
</head>
<body>
<div id="tooltip"></div>

<!-- ★ three と OrbitControls 読み込みは今のまま r147 でOK -->
<script src="https://cdn.jsdelivr.net/npm/three@0.147.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
  
/* ===== 0.基本セットアップ ===== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xcccccc);
scene.add(new THREE.AxesHelper(10));

const camera   = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,1000);
camera.position.set(0,18,23);
const radius = camera.position.length();   // 現在のカメラ距離をそのまま半径に
const clock  = new THREE.Clock();          // 経過時間を測る時計

const REV_PER_MIN   = 0.5;   // 1回転 / 1分（=60秒） に相当する角速度［ラジアン/秒］
const ANGULAR_SPEED = REV_PER_MIN * 2 * Math.PI / 60;  // ω = 2π / 60

const AUTO_DELAY_MS = 10_000;                    // 無操作10秒で自動回転再開
let  autoRotate     = true;                      // 現在自動回転中？
let  lastUserTime   = performance.now();         // 最後に操作した時刻
let  angleOffset    = 0;                         // 再開時の位相補正用
const radius        = camera.position.length();  // 回転半径を初期距離で固定
let  autoStartTime  = performance.now();         // 自動回転の基準時刻

/* ========= 01. ポインター操作で停止 ========= */
function markUserInteraction(){
  autoRotate   = false;                          // 止める
  lastUserTime = performance.now();
  angleOffset  = Math.atan2(camera.position.x, camera.position.z); // 現在の位相
}
addEventListener('pointerdown', markUserInteraction);
  
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera,renderer.domElement);
controls.target.set(0,5,0); controls.update();

/* ===== 1.ライト ===== */
scene.add(new THREE.AmbientLight(0x888888));
const dir = new THREE.DirectionalLight(0xffffff,1);
dir.position.set(30,100,30); scene.add(dir);

/* ========= モデル読み込み ========= */
new THREE.GLTFLoader().load('model6.glb', g => {
  const m = g.scene;
  m.scale.set(0.1, 0.1, 0.1);
  m.position.set(0, 0, 0);      // 必要なら位置も

/* --- ここから 角度を degree で指定 ---------- */
  const deg   = d => d * Math.PI / 180;      // 変換ヘルパ
  const rot   = { x: 270, y: 0, z: 0 };      // ← 好きな角度（°）に変更
  m.rotation.set( deg(rot.x), deg(rot.y), deg(rot.z) );
/* ------------------------------------------- */

  scene.add(m);
});

  /* ===== 3.スプライト定義 & 生成 ===== */
const spriteInfo = [
  { img:'1.png', pos:[  1, 1,  1], label:'① 校庭の動画を見る',
    thumb:'thumb1.jpg', url:'https://youtu.be/3JjAXCMe9mc' },

  { img:'2.png', pos:[  2, 2, -7], label:'② 校舎の紹介',
    thumb:'thumb2.jpg', url:'https://youtu.be/k4PDAdRwEDo' },

  { img:'3.png', pos:[ -5, 3, -4], label:'③ 体育館の様子',
    thumb:'thumb3.jpg', url:'https://youtu.be/klDA1XaWdmQ' },

  { img:'4.png', pos:[-10, 4,  2], label:'④ プールエリア',
    thumb:'thumb4.jpg', url:'https://youtu.be/UMCrUJZyf_s' },

  { img:'5.png', pos:[  4, 2,  8], label:'⑤ 登校口付近',
    thumb:'thumb5.jpg', url:'https://youtu.be/gTFoiQv0ubE' }
];

const loader = new THREE.TextureLoader();
const sprites=[], group=new THREE.Group();       // グループにまとめると管理しやすい
spriteInfo.forEach(info=>{
  const sp=new THREE.Sprite(new THREE.SpriteMaterial({map:loader.load(info.img),transparent:true}));
  sp.scale.set(1,1,1);
  sp.position.set(...info.pos);
  sp.userData=info;
  sprites.push(sp); group.add(sp);
});
scene.add(group);

/* ===== 4.ホバー & クリック ===== */
const ray   = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const tip   = document.getElementById('tooltip');
let current=null;

function setMouse(e){
  mouse.x =  (e.clientX/innerWidth)*2-1;
  mouse.y = -(e.clientY/innerHeight)*2+1;
}
addEventListener('mousemove',e=>{
  setMouse(e);
  ray.setFromCamera(mouse,camera);
  const hit=ray.intersectObjects(sprites)[0]?.object||null;

  if(hit!==current){
    current=hit;
    if(current){
      const d=current.userData;
      tip.innerHTML=`<img src="${d.thumb}"><strong>${d.label}</strong>`;
      tip.style.left=e.clientX+12+'px';
      tip.style.top =e.clientY+12+'px';
      tip.style.display='block';
    }else tip.style.display='none';
  }
});
addEventListener('click',()=>{
  if(current) window.open(current.userData.url,'_blank');
});

/* ========= 5. アニメーションループ ========= */
function animate(){
requestAnimationFrame(animate);

const now = performance.now();

/* 5-A. 自動 → 手動 に切り替わって10秒経過したら再度自動開始 */
if(!autoRotate && now - lastUserTime > AUTO_DELAY_MS){
  autoRotate    = true;
  autoStartTime = now - angleOffset/ANGULAR_SPEED * 1000; // 位相を保ったまま再開
}

/* 5-B. 自動回転モードのときだけカメラ座標を更新 */
  if(autoRotate){
    const t     = (now - autoStartTime)/1000;     // 秒
    const theta = ANGULAR_SPEED * t;
    camera.position.x =  radius * Math.sin(theta);
    camera.position.z =  radius * Math.cos(theta);
    camera.lookAt(0,5,0);                         // 注視点（必要なら変える）
  }

  controls.update();                              // 手動時の操作も有効
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
